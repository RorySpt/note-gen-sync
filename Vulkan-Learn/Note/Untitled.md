## 执行模型

Vulkan 的设计核心是​**显式控制**​，这意味着应用程序需要主动管理和协调系统中的各个组件，而不是依赖驱动程序的自动优化。

Vulkan 允许用户访问一个或多个设备，每个设备又可提供一个或多个队列，这些队列可以彼此异步地处理任务。设备所支持的队列集合被划分为不同的家族。每个家族支持一种或多种功能，并且可能包含具有相似特性的多个队列。同一家族内的队列被认为是相互兼容的，为某个家族的队列生成的工作可以在该家族内的任何队列上执行。

设备内存由应用程序明确管理。每个设备可以声明一个或多个堆，代表不同的内存区域。内存堆要么是设备本地的，要么是主机本地的，但总是对设备可见。

三个核心概念：​**设备与队列**​、**队列家族** 以及​**内存架构**​。

### 设备与队列


* ​**设备**​：在 Vulkan 中，一个“设备”通常代表一个物理硬件，比如一块 GPU。一个系统可以有多个设备。
* ​**队列**​：队列是 GPU 上实际**执行工作**的单元。你可以把队列想象成是 GPU 上的一个“流水线”或“处理器核心”。应用程序将命令（如绘制、计算、数据拷贝）提交到队列中，由队列异步地执行这些命令。

**关键点：异步性**
不同的队列可以**并行地、异步地**处理工作。这意味着一个队列在执行图形渲染的同时，另一个队列可以执行计算任务，第三个队列可以同时拷贝数据，从而极大地提高了硬件利用率和性能。

### 队列家族

这是 Vulkan 中一个非常重要的概念，用于对队列进行分类和管理。

* ​**家族**​：设备支持的队列集合被划分为不同的“家族”。每个家族代表一种特定类型的“功能”。
* ​**功能类型**​：规范中定义的队列功能包括：
  * ​**图形**​：支持绘制、光栅化等渲染管线操作。
  * ​**计算**​：支持通用计算着色器。
  * ​**传输**​：专门用于高效的数据拷贝。
  * ​**视频解码/编码**​：处理视频流的硬件加速。
  * ​**稀疏内存管理**​：处理大型或非连续资源。
  * ​**保护内存管理**​：用于安全相关内容。
* **家族内的兼容性**
  * ​**同一家族内的队列是兼容的**​。如果你为一个图形队列家族创建了工作任务，那么这个任务可以被提交到该家族中的**任何一个**队列上执行。这为负载均衡提供了灵活性。
  * ​**不同家族的队列可能不兼容**​。你不能将一个为图形家族创建的任务直接提交到计算家族的队列上。
* **为什么有多个相似家族？**
  文中提到，一个设备可能会报告​**多个相似的队列家族**​。例如，一个 GPU 可能有两个图形队列家族，它们的功能几乎一模一样。
  * ​**原因​**​：这通常表示这些队列在硬件上是独立的执行单元，它们之间不能直接共享资源或同步状态。虽然能力相似，但它们并非完全“兼容”，你需要为每个家族分别管理其工作负载。

### 内存架构

Vulkan 要求应用程序​**显式地管理设备内存**​，这与 OpenGL 等 API 的自动内存管理有本质区别。

* **内存堆**
  
  * 每个设备都提供一个或多个“堆”。堆代表了物理上不同的内存区域（比如 GPU 上的显存，或者系统主板上的 RAM）。
  * 堆有两种基本属性：
    * ​**设备本地**​：物理上离设备（GPU）更近，访问速度极快。通常就是我们所知的“显存”。
    * ​**主机本地**​：物理上离 CPU（主机）更近。
* **内存类型**
  
  * 每个堆都提供多种“内存类型”，它们描述了如何在该堆上分配和使用内存。
  * 内存类型通过**属性**来定义其可见性和缓存行为。文中给出了几个典型例子：
  
  1. **`DEVICE_LOCAL`**
     * ​**描述**​：物理连接到设备的超快内存。
     * ​**用途**​：存储最常被 GPU 访问的数据，如帧缓冲区、纹理、顶点缓冲区。
     * ​**注意**​：CPU 通常**无法直接访问**这块内存。
  2. **`DEVICE_LOCAL` | `HOST_VISIBLE`**
     * ​**描述**​：既是设备本地内存，又可以被主机（CPU）映射和访问。
     * ​**用途**​：用于需要**频繁由 CPU 更新**且由 GPU 读取的数据（即“动态”资源）。这在现代统一内存架构的硬件（如集成显卡、某些游戏主机）上很常见。虽然它可能比纯设备本地内存慢一点，但避免了从主机内存到设备内存的显式拷贝。
  3. **`HOST_LOCAL` | `HOST_VISIBLE`**
     * ​**描述**​：主机本地的内存，对主机和设备都可见。
     * ​**用途**​：通常就是系统 RAM。GPU 可以通过 PCIe 总线访问它，但速度较慢。适合存储不常被 GPU 访问的数据，或作为数据上传到 `DEVICE_LOCAL` 内存的中转站。
* **简单架构**
  
  * 对于某些简单系统（比如老的或非常基础的硬件），可能只有一个内存堆，所有类型的内存分配都在这个堆上进行。

### 队列操作

整个流程可以概括为：
**录制命令缓冲区 → 提交到队列 → 异步执行**

1. ​**录制**​：所有 GPU 命令（如绘制、计算）都预先录制到**命令缓冲区**中。
2. ​**提交**​：通过 `vkQueueSubmit` 等提交命令，将一个或多个命令缓冲区作为一批工作提交到队列。
3. ​**执行**​：提交后，GPU 开始异步执行这些命令，CPU 无需等待，可以继续做其他事情。

#### 1. 并行性与无序性

Vulkan 的执行模型是高度并行和无序的，这是其高性能的关键，但也带来了复杂性。

* ​**不同队列之间**​：​**没有隐式排序**​。比如队列 A 的提交和队列 B 的提交，谁先执行、谁后执行、是否重叠，都是不确定的。
* ​**同一队列内部**​：命令缓冲区之间的边界​**不提供强制的排序保证**​。虽然它们遵循“提交顺序”，但 GPU 为了优化，仍然可能让不同命令缓冲区中的命令**重叠执行**或​**乱序执行**​，只要没有数据依赖。

​**设计哲学**​：Vulkan 默认认为所有操作都是并行且无序的，除非你**显式地**告诉它需要排序。

#### 2. 显式同步

由于隐式排序的缺失，我们必须使用**显式同步原语**来强制排序。文中提到了两种：

* ​**信号量**​：用于 **GPU 内部** 的同步，尤其是在**不同队列**之间或同一队列的**不同提交**之间。
  * 在提交工作时，可以指定：
    * ​**等待哪些信号量**​：工作必须等到这些信号量被触发后才开始。
    * ​**触发哪些信号量**​：工作完成后，会触发这些信号量，以通知其他工作可以开始了。
* ​**栅栏**​：用于 **CPU 和 GPU** 之间的同步。
  * CPU 可以“等待”一个栅栏，这会阻塞 CPU 直到 GPU 完成相关的工作并触发了该栅栏。

​**重要保证**​：

* 当一个信号量或栅栏被**触发**时，意味着​**之前提交的所有相关操作都已经完成**​，并且它们对内存的写入​**对后续操作是可见的**​。
* 当你在一个操作中**等待**一个已触发的信号量时，保证了之前操作的内存写入对当前操作是​**可见的**​。

#### 3. 命令的角色

命令缓冲区中的命令被分为四种角色，这有助于理解它们如何相互作用：

1. **动作命令**
   * ​**作用**​：执行实际工作，会​**修改内存**​（例如，将像素写入图像，将数据写入缓冲区）。
   * ​**例子**​：`vkCmdDraw`（绘制）, `vkCmdDispatch`（计算调度）。
   * ​**关键特性**​：在没有同步的情况下，多个 Action 命令可能会并行执行，导致​**数据竞争**​。
2. **状态设置命令**
   * ​**作用**​：更新命令缓冲区的​**当前状态**​，影响**后续**所有 Action 命令的行为。
   * ​**例子**​：`vkCmdBindPipeline`（绑定渲染管线）, `vkCmdSetViewport`（设置视口）。
   * ​**关键保证**​：状态命令的​**观察顺序是固定的**​。无论 Action 命令如何乱序执行，它“看到”的状态永远是它在命令缓冲区录制序列中的那个时间点的状态。这被称为“绘合同”或“状态一致性”。
3. **同步命令**
   * ​**作用**​：在 Action 命令之间​**强制引入排序**​，建立**执行依赖**和​**内存依赖**​。
   * ​**例子**​：`vkCmdPipelineBarrier`（管线屏障）。它可以确保屏障之前的所有命令在屏障之后的命令开始之前完成，并且内存写入对后续命令可见。
4. **间接命令**
   * ​**作用**​：执行那些没有直接录制在当前命令缓冲区中的命令。
   * ​**例子**​：`vkCmdExecuteCommands`（执行次级命令缓冲区）。

​**核心要点**​：
Vulkan 将控制权完全交给了开发者。它默认以最高性能（最无序）的方式运行。如果你需要保证操作的先后顺序，**必须**通过**同步原语（信号量、栅栏、屏障）** 来明确地建立依赖关系，否则就会面临数据竞争和未定义行为。这种显式控制是 Vulkan 高性能的代价，也是其力量的源泉。

## **对象模型**

### 对象与句柄

在 Vulkan 中，诸如设备、队列、缓冲区、图像等所有实体都被称为 ​**Vulkan 对象**​。应用程序并不直接操作这些对象本身，而是通过 **句柄** 来间接引用它们。

句柄分为两大类：**可调度句柄** 和 ​**非可调度句柄**​。

---

### 1. 可调度句柄

* ​**本质**​：它是一个 ​**指针**​，指向一个不透明的类型（你可以理解为一个内部结构体）。
* ​**作用**​：
  1. ​**API 分派**​：这是它的核心作用。Vulkan 的每个 API 命令（如 `vkCmdDraw`, `vkCreateImage`）的第一个参数都是一个可调度句柄类型（如 `VkCommandBuffer`, `VkDevice`）。这个指针被 Vulkan 的加载层或验证层用来正确地路由和拦截 API 调用。
  2. ​**唯一性**​：在对象的整个生命周期内，​**每个可调度对象都必须拥有一个唯一的句柄值**​。这确保了每个对象都能被明确无误地识别。

​**常见例子**​：`VkInstance`, `VkDevice`, `VkQueue`, `VkCommandBuffer`。

---

### 2. 非可调度句柄

* ​**本质**​：它是一个 ​**64位整数**​。
* ​**行为** （取决于 `privateData` 特性）：
  **情况一：`privateData` 特性被启用**
  
  
  
  * 行为与可调度句柄类似，作为对一个底层对象的 ​**引用**​。
  * 在创建它的那个 `VkDevice` 上，其句柄值在对象的生命周期内必须是唯一的。
  
  **情况二：`privateData` 特性未被启用**
  
  * 这是更复杂也更有趣的情况。句柄​**可能不再是一个简单的引用**​，而是​**直接在整数值中编码了对象信息**​。
  * ​**后果**​：
    * ​**句柄可能不唯一**​：两个不同的对象（比如两个图像）可能拥有相同的整数句柄值。
    * ​**销毁安全性**​：即使句柄值不唯一，系统也必须保证：
      1. 销毁一个句柄（比如一个 `VkImage`），不会导致具有相同句柄值的其他类型对象（比如一个 `VkBuffer`）失效。
      2. 如果一个句柄值被创建的次数多于被销毁的次数，那么销毁其中一个对象，不会使其他拥有相同句柄值的同类型对象失效。
  
  ​**设计意图**​：这种设计允许驱动程序进行深度优化。例如，驱动程序可以直接将内存地址或索引打包进 64 位整数中，避免了在内部进行耗时的句柄到对象的查找表查询，从而提升性能。

​**常见例子**​：`VkImage`, `VkBuffer`, `VkSampler`, `VkDescriptorSet`。

---

### 3. 设备私有性

这是一个非常重要的规则：

> 所有从一个 `VkDevice` 创建或分配的对象（即那些以 `VkDevice` 作为第一个创建参数的），都是该设备的 ​**私有对象**​，**严禁** 在其他的 `VkDevice` 上使用。

* ​**原因​**​：不同的 `VkDevice`（即使在同一块物理 GPU 上）可能具有不同的驱动内部状态、内存分配器和资源管理器。跨设备使用资源会导致未定义行为。
* ​**例子**​：你不能将在 `DeviceA` 上创建的 `VkImage` 用在为 `DeviceB` 录制的 `VkCommandBuffer` 中。
* ​**跨设备操作**​：如果需要在设备间共享资源，必须使用显式的跨设备共享机制（通常涉及外部内存句柄等高级特性），而不是直接传递对象句柄。

